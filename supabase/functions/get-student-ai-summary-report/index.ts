
// @deno-types="https://deno.land/x/servest@v1.3.1/types/react/index.d.ts" 
// The above is a common workaround for Deno type errors in some editors, but might not be strictly necessary
// or correct for this specific use case. The primary issue is environment setup for Deno.

// filepath: g:\\eduBuddy\\edubuddy\\supabase\\functions\\get-student-ai-summary-report\\index.ts
// Supabase Edge Function: get-student-ai-summary-report

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2"; // Standard Supabase client

// Helper function to create CORS headers
const corsHeaders = {
  'Access-Control-Allow-Origin': '*', // Allow all origins (for development)
  'Access-Control-Allow-Methods': 'POST, OPTIONS', // Allow POST and OPTIONS requests
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type', // Common headers
};

// Define interfaces for report structure (mirroring frontend)
interface QuizQuestionReview {
  questionText: string;
  studentAnswer: string;
  correctAnswer: string;
  isCorrect: boolean;
}
interface QuizReviewDetail {
  quizId: string;
  quizTitle: string;
  completedDate: string;
  score: number;
  maxScore: number;
  percentage: number;
  questions: QuizQuestionReview[]; 
}
interface AISummaryReport {
  overallSummary: string;
  strengths: string[];
  areasForImprovement: string[];
  activityAnalysis: string;
  quizReview?: QuizReviewDetail[];
  knowledgeGrowthChartData?: { date: string; score: number }[]; // For graphics
  gradeLevel?: string;
  studentName?: string; // Added studentName
  generatedAt?: string; // Timestamp of when this report was generated
  reportId?: string; // ID of the report in the database
}

// Mock AI Service
async function mockAIService(
  studentId: string,
  gradeLevel: string,
  studentName: string,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _recentActivity: any[] // Placeholder for actual activity data
): Promise<AISummaryReport> {
  // Simulate AI processing delay
  await new Promise(resolve => setTimeout(resolve, 1000));

  // Mock data, similar to frontend but could be more dynamic
  const report: AISummaryReport = {
    studentName: studentName || "Student",
    overallSummary: `This is a mock AI summary for ${studentName || 'student'} (${gradeLevel}). It highlights progress and areas needing attention based on recent (mocked) activities.`,
    strengths: ["Good engagement in mock lessons", "Completed mock quizzes"],
    areasForImprovement: ["Understanding mock complex topics", "Mock quiz accuracy"],
    activityAnalysis: "Mock analysis: Student shows consistent effort. Further data will refine this.",
    quizReview: [
      {
        quizId: "mockQuiz1",
        quizTitle: "Mock Math Quiz (Generated by Edge Function)",
        completedDate: new Date().toISOString(),
        score: 7,
        maxScore: 10,
        percentage: 70,
        questions: [
          { questionText: "Mock Q1: 5 + 5 = ?", studentAnswer: "10", correctAnswer: "10", isCorrect: true },
          { questionText: "Mock Q2: 10 - 3 = ?", studentAnswer: "6", correctAnswer: "7", isCorrect: false },
        ],
      },
    ],
    knowledgeGrowthChartData: [
      { date: "2023-01-01", score: 60 },
      { date: "2023-02-01", score: 65 },
      { date: "2023-03-01", score: 75 },
      { date: "2023-04-01", score: 70 },
      { date: "2023-05-01", score: 80 },
    ],
    gradeLevel: gradeLevel,
    generatedAt: new Date().toISOString(),
  };
  return report;
}

serve(async (req) => {
  // Handle OPTIONS request for CORS preflight
  if (req.method === 'OPTIONS') {
    console.log('Handling OPTIONS request for get-student-ai-summary-report'); // Added for debugging
    // Using 204 No Content is a common practice for preflight responses
    return new Response(null, { 
      status: 204, 
      headers: corsHeaders 
    });
  }

  // For any other request type, apply CORS headers to all responses
  try {
    const { studentId, gradeLevel, studentName, forceRefresh } = await req.json();
    const supabaseUrl = Deno.env.get("SUPABASE_URL");
    const supabaseAnonKey = Deno.env.get("SUPABASE_ANON_KEY");

    if (!studentId || !gradeLevel) {
      return new Response(
        JSON.stringify({ error: "studentId and gradeLevel are required" }),
        { status: 400, headers: { "Content-Type": "application/json", ...corsHeaders } }
      );
    }

    if (!supabaseUrl || !supabaseAnonKey) {
      return new Response(
        JSON.stringify({ error: "Supabase environment variables not set" }),
        { status: 500, headers: { "Content-Type": "application/json", ...corsHeaders } }
      );
    }

    const supabase = createClient(supabaseUrl, supabaseAnonKey);

    let reportToReturn: AISummaryReport | null = null;
    const reportStalenessThresholdHours = 24; // Regenerate if older than 24 hours or new activity

    if (!forceRefresh) {
      // 1. Check for an existing, up-to-date report
      const { data: existingReportData, error: existingReportError } = await supabase
        .from("ai_student_reports")
        .select("id, report_data, last_activity_timestamp, generated_at")
        .eq("student_id", studentId)
        .eq("grade_level", gradeLevel) // Ensure grade level matches
        .order("generated_at", { ascending: false })
        .limit(1)
        .single();

      if (existingReportError && existingReportError.code !== 'PGRST116') { // PGRST116: single row not found
        console.error("Error fetching existing report:", existingReportError);
        // Potentially return error, or proceed to generate new one
      }

      if (existingReportData) {
        const report = existingReportData.report_data as AISummaryReport;
        report.reportId = existingReportData.id; // Add reportId
        const reportGeneratedAt = new Date(existingReportData.generated_at);
        const now = new Date();
        const reportAgeHours = (now.getTime() - reportGeneratedAt.getTime()) / (1000 * 60 * 60);

        // Check for new student activity (e.g., last quiz attempt)
        // This is a simplified check. A more robust solution might involve a dedicated 'last_activity' table or more complex queries.
        const { data: latestActivity, error: activityError } = await supabase
          .from("student_quiz_attempts") // Assuming this table exists and has student_id and attempted_at
          .select("attempted_at")
          .eq("student_id", studentId)
          .order("attempted_at", { ascending: false })
          .limit(1)
          .single();
        
        let isStaleByActivity = false;
        if (activityError && activityError.code !== 'PGRST116') {
            console.warn("Could not fetch latest activity to check staleness:", activityError.message);
        } else if (latestActivity && existingReportData.last_activity_timestamp) {
            if (new Date(latestActivity.attempted_at) > new Date(existingReportData.last_activity_timestamp)) {
                isStaleByActivity = true;
                console.log(`Report for student ${studentId} is stale due to new activity.`);
            }
        } else if (latestActivity && !existingReportData.last_activity_timestamp) {
            // Report exists but no last_activity_timestamp, consider it stale if there's any activity
            isStaleByActivity = true;
             console.log(`Report for student ${studentId} is stale (no previous activity timestamp, but new activity found).`);
        }


        if (reportAgeHours < reportStalenessThresholdHours && !isStaleByActivity) {
          console.log(`Returning existing report for student ${studentId}, generated at ${reportGeneratedAt.toISOString()}`);
          reportToReturn = report;
        } else {
          console.log(`Existing report for student ${studentId} is stale (age: ${reportAgeHours.toFixed(1)}h, new_activity_staleness: ${isStaleByActivity}). Regenerating.`);
        }
      }
    }

    if (!reportToReturn) {
      // 2. Fetch recent activity (mocked for now, replace with actual DB queries)
      // For a real implementation, you'd query student_quiz_attempts, lesson_completions, etc.
      const recentActivityData: any[] = []; // Placeholder

      // 3. Call AI service
      console.log(`Generating new AI summary report for student ${studentId}, grade ${gradeLevel}.`);
      const newReport = await mockAIService(studentId, gradeLevel, studentName, recentActivityData);
      newReport.generatedAt = new Date().toISOString(); // Ensure generatedAt is set

      // 4. Store new/updated report
      // Determine the latest activity timestamp to store with the report
      // This should be the timestamp of the most recent data point used to generate the report
      let currentLastActivityTimestamp = new Date(0).toISOString(); // Default to epoch if no activity
      const { data: latestActivityForStorage, error: latestActivityErrorStorage } = await supabase
        .from("student_quiz_attempts")
        .select("attempted_at")
        .eq("student_id", studentId)
        .order("attempted_at", { ascending: false })
        .limit(1)
        .single();

      if (latestActivityErrorStorage && latestActivityErrorStorage.code !== 'PGRST116') {
        console.warn("Could not fetch latest activity timestamp for storage:", latestActivityErrorStorage.message);
      } else if (latestActivityForStorage) {
        currentLastActivityTimestamp = latestActivityForStorage.attempted_at;
      }
      
      const { data: upsertedReport, error: upsertError } = await supabase
        .from("ai_student_reports")
        .upsert({
          student_id: studentId,
          report_data: newReport,
          last_activity_timestamp: currentLastActivityTimestamp, 
          generated_at: newReport.generatedAt,
          grade_level: gradeLevel,
        }, { 
            onConflict: 'student_id, grade_level', // Assumes a unique constraint on (student_id, grade_level)
                                                // If you want multiple reports per student/grade, adjust this or use insert.
                                                // For this use case, one latest report per student/grade seems appropriate.
        })
        .select("id") // Return the ID of the upserted row
        .single();

      if (upsertError) {
        console.error("Error storing new AI report:", upsertError);
        // Decide if to return the newReport even if storage failed, or an error
        return new Response(
          JSON.stringify({ error: "Failed to store AI report", details: upsertError.message }),
          { status: 500, headers: { "Content-Type": "application/json", ...corsHeaders } }
        );
      }
      
      if (upsertedReport) {
        newReport.reportId = upsertedReport.id; // Add the new report's ID
      }
      reportToReturn = newReport;
    }

    // 5. Return the report
    return new Response(
      JSON.stringify(reportToReturn),
      { headers: { "Content-Type": "application/json", "Cache-Control": "no-cache", ...corsHeaders } } 
    );

  } catch (error) {
    console.error("Error in get-student-ai-summary-report function:", error);
    return new Response(
      JSON.stringify({ error: "Internal server error", details: error.message }),
      { status: 500, headers: { "Content-Type": "application/json", ...corsHeaders } }
    );
  }
});

/*
Table: ai_student_reports
Columns:
  id: uuid (Primary Key, default: uuid_generate_v4())
  student_id: uuid (Foreign Key to your students table, if applicable, or just an identifier)
  grade_level: text (e.g., 'k-3', '4-6', '7-9')
  report_data: jsonb (Stores the AISummaryReport object)
  last_activity_timestamp: timestamptz (Timestamp of the latest student activity used for this report)
  generated_at: timestamptz (default: now())
  created_at: timestamptz (default: now())
  updated_at: timestamptz (default: now())

Indexes:
  CREATE INDEX idx_ai_student_reports_student_id_grade_level ON ai_student_reports(student_id, grade_level);
  -- Consider a unique constraint if you only want one report per student per grade level.
  -- ALTER TABLE ai_student_reports ADD CONSTRAINT unique_student_grade_report UNIQUE (student_id, grade_level);
  -- If using upsert with onConflict: 'student_id, grade_level', this unique constraint is required.

Example Supabase CLI command to create the table (run in SQL editor or as migration):
CREATE TABLE public.ai_student_reports (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  student_id uuid NOT NULL,
  grade_level text NOT NULL,
  report_data jsonb NOT NULL,
  last_activity_timestamp timestamptz NULL,
  generated_at timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT ai_student_reports_pkey PRIMARY KEY (id),
  CONSTRAINT unique_student_grade_report UNIQUE (student_id, grade_level) -- Added for upsert
);

ALTER TABLE public.ai_student_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Enable read access for authenticated users" ON public.ai_student_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Enable insert access for authenticated users" ON public.ai_student_reports FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Enable update access for authenticated users" ON public.ai_student_reports FOR UPDATE USING (auth.role() = 'authenticated');
*/
